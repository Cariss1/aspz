

Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку: $ ulimit -n $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3000 $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3001 $ ulimit -n 2000 $ ulimit -n $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3000

Як наступне вправу, повторіть перераховані команди з root-правами.


У цьому завданні я перевірив та змінив ліміт на кількість відкритих файлів у Docker-контейнері за допомогою команди ulimit. Спочатку я перевірив поточний ліміт, а потім змінював його на 3000, 3001 і 2000, щоб спостерігати за впливом на систему. Також я повторив ці дії з правами адміністратора. З правами адміністратора можна змінювати ліміти ресурсів системи, коли це недоступно звичайному користувачеві, що дає більше можливостей для керування та оптимізації роботи контейнера.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p3/p3.1/Знімок%20екрана%202025-05-05%20184116.png)
![Example Image](https://github.com/dims3926r/aspz/blob/main/p3/p3.1/Знімок%20екрана%202025-05-05%20184132.png)


Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.

Програма імітує кидання шестигранного кубика та записує результати в файл. Для цього спочатку встановлюється обмеження на розмір файлу, використовуючи функцію setrlimit, де визначається максимальний розмір файлу (у цьому випадку 3 байти). Якщо розмір файлу перевищує цей ліміт, генерується сигнал SIGXFSZ, який перехоплюється в обробнику, що виводить повідомлення про помилку та завершення програми.

У головній частині програми за допомогою функції rand() генерується випадкове число від 1 до 6, що імітує результат кидка кубика. Результати кидків записуються в файл dice.txt. Після кожного запису виконується команда fflush, щоб примусово записати дані в файл. Якщо файл досягне максимального розміру, програма зупиниться, і виведе повідомлення про помилку.

Таким чином, програма дозволяє імітувати кидки кубика з фіксованим лімітом на розмір файлу, обробляючи випадки перевищення цього ліміту коректно.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p3/p3.3/image.png)


Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.


Програма імітує лотерею, вибираючи 7 чисел з діапазону від 1 до 49 і 6 чисел з 36. Вона встановлює обмеження на час процесора за допомогою setrlimit, і якщо програма перевищує цей ліміт, вона отримує сигнал SIGXCPU, який обробляється функцією, що виводить повідомлення про завершення програми через перевищення ліміту часу. Вибір чисел здійснюється унікально, використовуючи масив для відстеження вже вибраних чисел.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p3/p3.4/image.png)

Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів. Програма має: перевіряти, чи передано два аргументи, інакше виводити "Program need two arguments"; перевіряти доступність першого файлу для читання, інакше виводити "Cannot open file .... for reading"; перевіряти доступність другого файлу для запису, інакше виводити "Cannot open file .... for writing"; обробляти ситуацію перевищення обмеження на розмір файлу.


Ця програма копіює вміст одного файлу в інший. Вона перевіряє, чи можна відкрити файли для читання та запису, і зчитує дані блоками, щоб записати їх у новий файл Якщо файл неможливо відкрити — виводиться повідомлення про помилку

![Example Image](https://github.com/dims3926r/aspz/blob/main/p3/p3.5/image.png)



Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.


Ця програма ілюструє рекурсію з великою глибиною. Функція `recursive_function` викликає саму себе, зменшуючи значення лічильника глибини, поки він не досягне нуля. Кожен виклик створює запис у стеку, і при великій кількості таких викликів може статися переповнення стеку, що призведе до аварійного завершення програми.

![Example Image](https://github.com/dims3926r/aspz/blob/main/p3/p3.6/image.png)


![image](https://github.com/user-attachments/assets/4e6da5fb-f407-4a7a-8889-04443a461db4)

Дослідження впливу ulimit -l дозволяє зрозуміти, яку кількість пам’яті процес може зафіксувати (lock) в оперативній пам’яті — тобто захистити від підкачки (swap). 

Тестова програма

![image](https://github.com/user-attachments/assets/a8ef0fdb-1088-46e2-8fd7-d96df733297a)

![image](https://github.com/user-attachments/assets/03c0e168-1b44-432f-9f9b-d30a0c460733)

Поведінка mlock() залежно від ulimit -l:

Якщо значення ulimit -l менше ніж 100000 (тобто менше 100 МБ), то при спробі викликати mlock() для блокування памʼяті програма отримає помилку ENOMEM, яка означає, що недостатньо дозволеної памʼяті для фіксації.
Якщо значення ulimit -l дорівнює або більше 100000 (100 МБ і більше), тоді mlock() працює успішно — памʼять буде зафіксована в оперативній памʼяті та не буде підлягати підкачці (swap).


