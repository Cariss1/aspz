![image](https://github.com/user-attachments/assets/51036603-0c8e-4e45-809a-5b9486d59392)

Теоретично, обсяг пам'яті, який можна передати в malloc(), визначається типом size_t, який на 64-бітній системі займає 8 байт (64 біти). Це дозволяє адресувати до 2⁶⁴ байт, або 16 ексабайт. Однак на практиці обмеження значно менші через кілька факторів. Сучасні 64-бітні процесори, такі як x86_64, використовують лише 48 біт для адресації пам'яті, що обмежує доступну віртуальну пам'ять до 256 терабайт. Деякі нові процесори підтримують 57 біт, що дає максимум 128 петабайт, але повна 64-бітна адресація не застосовується. Окрім того, операційні системи вводять додаткові обмеження, а фізична пам'ять часто набагато менша за теоретичні ліміти. Тому, хоча malloc() може теоретично виділити до 16 ЕБ, на практиці максимальний розмір пам'яті обмежений до 8 ЕБ або навіть менше.

![image](https://github.com/user-attachments/assets/86e8649a-c330-4154-8ae6-8893ffdea92a)

Функція malloc(3) приймає аргумент типу size_t, який є беззнаковим (unsigned). Якщо передати від’ємне число, воно буде неявно перетворено на дуже велике додатнє значення через модульну арифметику.Якщо num оголошено як int (знаковий тип), то переповнення при множенні призведе до від’ємного значення, яке malloc інтерпретує як дуже велике додатнє через size_t. На x86_64 це призводить до спроби виділити >128 ТіБ, що закінчується ENOMEM. На x86 переповнення обрізається до 32 бітів, але malloc все одно не зможе виділити 4 ГіБ через обмеження адресного простору.

![image](https://github.com/user-attachments/assets/178ea138-7c78-43cf-be64-ede3a03b0d8a)


![image](https://github.com/user-attachments/assets/aae71df0-983e-42fd-908e-4cf65718e7b4)

Стандарт C (C99, C11) залишає поведінку malloc(0) невизначеною (implementation-defined). Можливі варіанти:
Повертає NULL (якщо розмір нульовий, це трактується як помилка).
Повертає не-NULL вказівник, який можна передати у free() (але не можна використовувати для доступу до пам'яті).
Чому так відбувається?
Glibc (Linux):
malloc(0) виділяє мінімальний блок пам'яті (наприклад, 16 байт для алісингу або відладки), тому повертає дійсний вказівник.
Стандарт C:
Не вимагає, щоб malloc(0) повертав NULL, але гарантує, що free() може приймати будь-який вказівник від malloc(0) (навіть якщо він не NULL).

![image](https://github.com/user-attachments/assets/0784c5d1-e01c-4123-879f-d03ab62b6255)

Код має серйозну помилку: після виклику free(ptr) у циклі, змінна ptr стає "висячим" вказівником (dangling pointer). Якщо умова циклу some-condition-is-true залишається істинною, на наступній ітерації умовний блок if (!ptr) не виконається, бо ptr не NULL (він лише вказує на звільнену пам’ять), програма спробує використати ptr після free(), що призводить до невизначеної поведінки (можливий креш або пошкодження даних).


виправильний вивід
![image](https://github.com/user-attachments/assets/051b8120-705c-4f6b-bb28-c7f08aca4c25)


![image](https://github.com/user-attachments/assets/c3e75ba3-4488-478c-8bfc-d7b35ceba0ad)

Якщо realloc() не зможе виділити нову пам’ять, вона:
Поверне NULL
Залишить початковий блок ptr неушкодженим
size_t huge_size = (size_t) -1; намагається викликати realloc() з найбільшим можливим значенням. У більшості ОС це викличе невдачу виділення
![image](https://github.com/user-attachments/assets/4067a312-c74a-4fd6-ba70-4f3a16e32009)


Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.

Що буде, якщо realloc() викликати з NULL?
Це еквівалентно виклику malloc(size). Тобто — виділяється новий блок пам’яті розміром size

Що буде, якщо realloc(ptr, 0)?
Якщо size == 0, результат залежить від реалізації стандартної бібліотеки (glibc, musl тощо):
Або:
realloc(ptr, 0) поводиться як free(ptr) і повертає NULL
Або:
Повертає ненульовий вказівник, який не можна використовувати
У більшості випадків краще явно викликати free(), якщо потрібно звільнити пам’ять
![image](https://github.com/user-attachments/assets/2787fd08-547b-4bd5-89bc-f868ae5a61db)

![image](https://github.com/user-attachments/assets/eed884b3-a7d6-4c84-913c-b777b28c8bd6)

realloc() не перевіряє переповнення при обчисленні розміру пам’яті (n * size). Це робить його потенційно небезпечним, оскільки при переповненні може виділитися менше пам’яті, ніж очікується, що призводить до вразливостей.
reallocarray() виконує перевірку переповнення перед виділенням пам’яті. Це робить його безпечнішим варіантом, особливо коли працюєш з масивами великих розмірів.
realloc() підтримується в C99 (стандартна мова C).
reallocarray() доступний у glibc 2.26+ і BSD-системах, тому підтримка трохи обмеженіша, але якщо вона є — краще його використовувати.

![image](https://github.com/user-attachments/assets/77eadbb8-e930-4ad1-9416-4fcd597f1d2b)

![image](https://github.com/user-attachments/assets/0040caed-62af-4f32-ab48-e15cb2aa21d7)

Що перевіряє цей код:
Виділяє 100 блоків по 100 МБ (до 10 ГБ)
memset() змушує ОС реально виділити пам’ять (lazy allocation → off)
Повідомляє, коли виділення провалюється
Можна побачити:
на якому обсязі ОС не може виділити пам’ять
як поводиться malloc під тиском

![image](https://github.com/user-attachments/assets/e8101530-f1a3-418f-806e-a40c37bf38e2)


